/*****************************************************************************
 * University of Southern Denmark
 * Robotics 4th Semester project
 *
 * MODULENAME.: main.c
 *
 * PROJECT....: Control and Regulation Project
 *
 * DESCRIPTION: main file for TIVA C TM4C123GH6PM
 *
 * Change Log:
 ******************************************************************************
 * Date    Id    Change
 * 240401
 * --------------------
 * 240401  MoH   Module created.
 *
 *****************************************************************************/

/***************************** Include files *******************************/
#include <stdint.h>
#include "stdio.h"
#include "SPI1.h"
#include "delay.h"
#include "led.h"
#include "tm4c123gh6pm.h"
#include "uart.h"
#include "emp_type.h"

/*****************************    Defines    *******************************/


/*****************************   Constants   *******************************/
/*****************************   Variables   *******************************/
  INT16S input;
  INT16S last_input = 0;
/*****************************   Functions   *******************************/
void send_char(INT8U chr) {
  while (UART0_FR_R & (1 << 5))
    ;
  UART0_DR_R = chr;
}

void send_string(char *str) {
  while (*str) {
    send_char(*str);
    str++;
  }
}

void send_count(INT16U count) {
  send_char(count / 10000 + '0');
  count = count % 10000;
  send_char(count / 1000 + '0');
  count = count % 1000;
  send_char(count / 100 + '0');
  count = count % 100;
  send_char(count / 10 + '0');
  count = count % 10;
  send_char(count + '0');
}



INT16U voltage_to_duty_cycle(INT16S voltage){
    if (voltage < 0){
        voltage = -voltage;
    }

    INT16U duty_cycle = (voltage * 1023) / 12;

    if (duty_cycle > 1023){
        duty_cycle = 1023;
        return duty_cycle;
    } else {
        return duty_cycle;
    }
}

INT16U duty_cycle_to_angle(INT16S duty_cycle){
    INT16U angle = 0;

    if (duty_cycle < 0){
        duty_cycle = -duty_cycle;
    }

    angle = (duty_cycle / 450) * 360;

    return angle;
}

INT16S send_protocol(axis angle, INT16S voltage){
    /* The data packets is constructed of 16 bits:
    * M: Motor selection
    * S: 1 = negative & 0 = positive
    * D: Data
    * 0bMS000DDDDDDDDDD
    * */

    INT16U byte = 0;
    INT16U duty_cycle = 0;

    if (angle == PAN){
        byte |= 0b1000000000000000;
    }

    if (voltage < 0){
        byte |= 0b0100000000000000;
    }

    duty_cycle = voltage_to_duty_cycle(voltage);

    byte |= duty_cycle & 0b0000001111111111;

    return byte;
}

INT16S receive_protocol(INT16S data){
    INT16S received_data = 0;
    axis motor;

    if (data & 0b1000000000000000){
        motor = PAN;
    } else {
        motor = TILT;
    }

    received_data = duty_cycle_to_angle(data & 0b0000001111111111);

    if (data & 0b0100000000000000){
        received_data |= 0b0100000000000000;
    }

    if (motor == PAN){
        send_string("Motor: PAN");
    } else {
        send_string("Motor: TILT");
    }
    if (received_data < 0){
        send_string("Direction: Negative, ");
    } else {
        send_string("Direction: Positive, ");
    }
    send_string(", Angle: ");
    send_count(received_data);

    return received_data;
}


int main(void) {
  SPI1_init();
  LED_init();
  setup_uart0();


  while (1) {

    if ((GPIO_PORTF_DATA_R & (1 << 4)) == 0) // Check if SW1 is pressed
    {
      GPIO_PORTF_DATA_R |= (1 << 1); // Turn on red led
      send_protocol(0, 8.3); // send_protocol(TILT = 0 & PAN = 1, voltage)
      while ((GPIO_PORTF_DATA_R & (1 << 4)) == 0)
        ;// Only send one value per press
    } else {
      // Turn off red led
      GPIO_PORTF_DATA_R &= ~(1 << 1);
    }

    if ((GPIO_PORTF_DATA_R & (1 << 0)) == 0) // Check if SW2 is pressed
    {
      GPIO_PORTF_DATA_R |= (1 << 3); // Turn on green led
      send_protocol(0, 5.3); // send_protocol(TILT = 0 & PAN = 1, voltage)
      while ((GPIO_PORTF_DATA_R & (1 << 0)) == 0)
        ;// Only send one value per press
    } else {
      // Turn off green led
      GPIO_PORTF_DATA_R &= ~(1 << 3);
    }



    if (!(GPIO_PORTF_DATA_R & (1 << 4)) == 0) // When Switches is not pressed check for MISO
    {
        receive_protocol(input);
        if (input != last_input)
        {
            last_input = input;

            GPIO_PORTF_DATA_R |= (1 << 2); // Turn on blue LED if the Rx was success
            delay_ms(1000);
            GPIO_PORTF_DATA_R &= ~(1 << 2); // Turn off blue LED
        }
    }
  }
}
