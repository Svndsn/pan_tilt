/*****************************************************************************
 * University of Southern Denmark
 * Robotics 4th Semester project
 *
 * MODULENAME.: main.c
 *
 * PROJECT....: Control and Regulation Project
 *
 * DESCRIPTION: main file for TIVA C TM4C123GH6PM
 *
 * Change Log:
 ******************************************************************************
 * Date    Id    Change
 * 240401
 * --------------------
 * 240401  MoH   Module created.
 *
 *****************************************************************************/

/***************************** Include files *******************************/
#include <stdint.h>
#include "stdio.h"
#include "SPI1.h"
#include "delay.h"
#include "led.h"
#include "tm4c123gh6pm.h"
#include "uart.h"
#include "emp_type.h"

/*****************************    Defines    *******************************/


/*****************************   Constants   *******************************/
/*****************************   Variables   *******************************/

  short val1 = 0b0000000110010;
  short val2 = 0b0000000000000;
  short input;
  short last_input = 0;
/*****************************   Functions   *******************************/
void send_char(INT8U chr) {
  while (UART0_FR_R & (1 << 5))
    ;
  UART0_DR_R = chr;
}

void send_string(char *str) {
  while (*str) {
    send_char(*str);
    str++;
  }
}

void send_count(INT16U count) {
  send_char(count / 10000 + '0');
  count = count % 10000;
  send_char(count / 1000 + '0');
  count = count % 1000;
  send_char(count / 100 + '0');
  count = count % 100;
  send_char(count / 10 + '0');
  count = count % 10;
  send_char(count + '0');
}



INT16U voltage_to_duty_cycle(INT8S voltage){
    if (voltage < 0){
        voltage = -voltage;
    }

    INT16U duty_cycle = (voltage * 1023) / 12;

    if (duty_cycle > 1023){
        duty_cycle = 1023;
        return duty_cycle;
    } else {
        return duty_cycle;
    }
}
void send_protocol(axis angle, INT8S voltage){
    /* The data packets is constructed of 16 bits:
    * M: Motor selection
    * S: 1 = negative & 0 = positive
    * D: Data
    * 0bMS000DDDDDDDDDD
    * */

    INT16U byte = 0;
    INT16U duty_cycle = 0;

    if(angle == PAN){
        byte |= 0b1000000000000000;
    }

    if(duty_cycle < 0){
        byte |= 0b0100000000000000;
        duty_cycle = -duty_cycle;
    }

    duty_cycle = voltage_to_duty_cycle(voltage);

    byte |= duty_cycle & 0b0000001111111111;

    return byte;
}

void receive_protocol(INT16S data){
    INT16U received_data = 0;

    if(data & 0b1000000000000000){
        received_data |= 0b1000000000000000;
    }

    if(data & 0b0100000000000000){
        received_data |= 0b0100000000000000;
    }

    received_data = data & 0b0000001111111111;

    return received_data;
}


int main(void) {
  SPI1_init();
  LED_init();
  setup_uart0();


  while (1) {

    if ((GPIO_PORTF_DATA_R & (1 << 4)) == 0) // Check if SW1 is pressed
    {
      GPIO_PORTF_DATA_R |= (1 << 1); // Turn on red led
      SPI1_Write(val1);
      while ((GPIO_PORTF_DATA_R & (1 << 4)) == 0)
        ;// Only send one value per press
    } else {
      // Turn off red led
      GPIO_PORTF_DATA_R &= ~(1 << 1);
    }

    if ((GPIO_PORTF_DATA_R & (1 << 0)) == 0) // Check if SW2 is pressed
    {
      GPIO_PORTF_DATA_R |= (1 << 3); // Turn on green led
      SPI1_Write(val2);
      while ((GPIO_PORTF_DATA_R & (1 << 0)) == 0)
        ;// Only send one value per press
    } else {
      // Turn off green led
      GPIO_PORTF_DATA_R &= ~(1 << 3);
    }



    if (!(GPIO_PORTF_DATA_R & (1 << 4)) == 0) // When Switches is not pressed check for MISO
    {
        SPI1_Read(&input);
        if (input != last_input)
        {
            last_input = input;
            send_count(input);
            send_char('\n');

            GPIO_PORTF_DATA_R |= (1 << 2); // Turn on blue LED if the Rx was success
            delay_ms(1000);
            GPIO_PORTF_DATA_R &= ~(1 << 2); // Turn off blue LED
        }
    }
  }
}
